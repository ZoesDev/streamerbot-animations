import { WebSocket as WebSocket$1 } from 'ws';

type StreamerbotAction = {
    enabled: boolean;
    group: string;
    id: string;
    name: string;
    subaction_count: number;
};

type StreamerbotPlatform = 'twitch' | 'youtube' | 'trovo';
type TwitchBroadcaster = {
    broadcastUser: string;
    broadcastUserName: string;
    broadcastUserId: string;
    broadcastIsAffiliate: boolean;
    broadcastIsPartner: boolean;
};
type TwitchBot = {
    botUser: string;
    botUserName: string;
    botUserId: string;
};
type YoutubeBroadcaster = {
    broadcastUserName: string;
    broadcastUserId: string;
    broadcastUserProfileImage: string;
};
type YouTubeBot = {
    botUserName: string;
    botUserId: string;
    botUserProfileImage: string;
};
type TrovoBroadcaster = {
    broadcasterLogin: string;
    broadcasterUserName: string;
    broadcasterUserId: string;
    broadcasterProfileUrl: string;
};
type TrovoBot = {
    botLogin: string;
    botUserName: string;
    botUserId: string;
    botProfileUrl: string;
};
type VStreamBroadcaster = {
    broadcasterLogin: string;
    broadcasterUserName: string;
    broadcasterUserId: string;
    broadcasterProfileUrl: string;
};
type VStreamBot = {
    botLogin: string;
    botUserName: string;
    botUserId: string;
    botProfileUrl: string;
};
type BroadcasterPlatforms = {
    twitch?: TwitchBroadcaster & TwitchBot;
    youtube?: YoutubeBroadcaster & YouTubeBot;
    trovo?: TrovoBroadcaster & TrovoBot;
    vstream?: VStreamBroadcaster & VStreamBot;
};
type BroadcasterPlatform = keyof BroadcasterPlatforms;
type MonitoredYouTubeBroadcast = {
    actualEndTime: string;
    actualStartTime: string;
    categoryId: string;
    channelId: string;
    description: string;
    id: string;
    liveChatId: string;
    privacy: 'public' | 'private' | 'unlisted' | (string & {});
    publishedAt: string;
    scheduledEndTime: string;
    scheduledStartTime: string;
    status: 'ready' | 'complete' | (string & {});
    title: string;
    tags: Array<string>;
    defaultLanguage: string;
    defaultAudioLanguage: string;
};
type Emote = {
    type: string;
    name: string;
    imageUrl: string;
};

type CreditsEvents = {
    cheers: Array<string>;
    follows: Array<string>;
    gameupdates: Array<string>;
    giftbombs: Array<string>;
    giftsubs: Array<string>;
    goalcontributions: Array<string>;
    hypetrains: Array<string>;
    pyramids: Array<string>;
    raided: Array<string>;
    resubs: Array<string>;
    rewardredemptions: Array<string>;
    subs: Array<string>;
};
type CreditsHypeTrain = {
    conductors: Array<string>;
    contributors: Array<string>;
};
type CreditsUsers = {
    editors: Array<string>;
    groups: Array<string>;
    moderators: Array<string>;
    subscribers: Array<string>;
    vips: Array<string>;
    users: Array<string>;
};
type CreditsTop = {
    allBits: Array<string>;
    monthBits: Array<string>;
    weekBits: Array<string>;
    channelRewards: Array<string>;
};
type StreamerbotCredits = {
    events: Partial<CreditsEvents>;
    users: Partial<CreditsUsers>;
    hypeTrain: CreditsHypeTrain;
    top: CreditsTop;
    groups: unknown;
    custom: unknown;
};

/**
 * List of all possible events that can be emitted by the Streamerbot WebSocket server
 *
 * Compiled from the raw output of the `GetEvents` request
 */
declare const StreamerbotEvents: {
    readonly General: readonly ["Custom"];
    readonly Twitch: readonly ["Follow", "Cheer", "Sub", "ReSub", "GiftSub", "GiftBomb", "Raid", "HypeTrainStart", "HypeTrainUpdate", "HypeTrainLevelUp", "HypeTrainEnd", "RewardRedemption", "RewardCreated", "RewardUpdated", "RewardDeleted", "CommunityGoalContribution", "CommunityGoalEnded", "StreamUpdate", "Whisper", "FirstWord", "SubCounterRollover", "BroadcastUpdate", "StreamUpdateGameOnConnect", "PresentViewers", "PollCreated", "PollUpdated", "PollCompleted", "PredictionCreated", "PredictionUpdated", "PredictionCompleted", "PredictionCanceled", "PredictionLocked", "ChatMessage", "ChatMessageDeleted", "UserTimedOut", "UserBanned", "Announcement", "AdRun", "BotWhisper", "CharityDonation", "CharityCompleted", "CoinCheer", "ShoutoutCreated", "UserUntimedOut", "CharityStarted", "CharityProgress", "GoalBegin", "GoalProgress", "GoalEnd", "ShieldModeBegin", "ShieldModeEnd", "AdMidRoll", "StreamOnline", "StreamOffline", "ShoutoutReceived", "ChatCleared", "RaidStart", "RaidSend", "RaidCancelled", "PollTerminated", "PyramidSuccess", "PyramidBroken", "ViewerCountUpdate", "GuestStarSessionBegin", "GuestStarSessionEnd", "GuestStarGuestUpdate", "GuestStarSlotUpdate", "GuestStarSettingsUpdate", "HypeChat", "RewardRedemptionUpdated", "HypeChatLevel", "BroadcasterAuthenticated", "BroadcasterChatConnected", "BroadcasterChatDisconnected", "BroadcasterPubSubConnected", "BroadcasterPubSubDisconnected", "BroadcasterEventSubConnected", "BroadcasterEventSubDisconnected", "SevenTVEmoteAdded", "SevenTVEmoteRemoved", "BetterTTVEmoteAdded", "BetterTTVEmoteRemoved", "BotChatConnected", "BotChatDisconnected", "UpcomingAd", "ModeratorAdded", "ModeratorRemoved", "VipAdded", "VipRemoved", "UserUnbanned", "UnbanRequestApproved", "UnbanRequestDenied", "AutomaticRewardRedemption", "UnbanRequestCreated", "ChatEmoteModeOn", "ChatEmoteModeOff", "ChatFollowerModeOn", "ChatFollowerModeOff", "ChatFollowerModeChanged", "ChatSlowModeOn", "ChatSlowModeOff", "ChatSlowModeChanged", "ChatSubscriberModeOn", "ChatSubscriberModeOff", "ChatUniqueModeOn", "ChatUniqueModeOff", "AutoModMessageHeld", "AutoModMessageUpdate", "BlockedTermsAdded", "BlockedTermsDeleted", "WarnedUser", "SuspiciousUserUpdate", "PermittedTermsAdded", "PermittedTermsDeleted", "WarningAcknowledged", "WatchStreak", "PollArchived", "SharedChatSessionBegin", "SharedChatSessionUpdate", "SharedChatSessionEnd", "PrimePaidUpgrade", "PayItForward", "GiftPaidUpgrade", "BitsBadgeTier", "SharedAnnouncement", "SharedRaid", "SharedPrimePaidUpgrade", "SharedGiftPaidUpgrade", "SharedPayItForward", "SharedSub", "SharedResub", "SharedSubGift", "SharedCommunitySubGift"];
    readonly Streamlabs: readonly ["Donation", "Merchandise", "Connected", "Disconnected", "CharityDonation"];
    readonly SpeechToText: readonly ["Dictation", "Command"];
    readonly Command: readonly ["Triggered", "Cooldown"];
    readonly FileWatcher: readonly ["Changed", "Created", "Deleted", "Renamed"];
    readonly FileTail: readonly ["Changed"];
    readonly Quote: readonly ["Added", "Show"];
    readonly Misc: readonly ["TimedAction", "Test", "ProcessStarted", "ProcessStopped", "ChatWindowAction", "StreamerbotStarted", "StreamerbotExiting", "ToastActivation", "GlobalVariableUpdated", "UserGlobalVariableUpdated", "ApplicationImport"];
    readonly Raw: readonly ["Action", "SubAction", "ActionCompleted"];
    readonly WebsocketClient: readonly ["Open", "Close", "Message"];
    readonly StreamElements: readonly ["Tip", "Merch", "Connected", "Disconnected", "Authenticated"];
    readonly WebsocketCustomServer: readonly ["Open", "Close", "Message"];
    readonly DonorDrive: readonly ["Donation", "ProfileUpdated", "Incentive"];
    readonly YouTube: readonly ["BroadcastStarted", "BroadcastEnded", "Message", "MessageDeleted", "UserBanned", "SuperChat", "SuperSticker", "NewSponsor", "MemberMileStone", "NewSponsorOnlyStarted", "NewSponsorOnlyEnded", "StatisticsUpdated", "BroadcastUpdated", "MembershipGift", "GiftMembershipReceived", "FirstWords", "PresentViewers", "NewSubscriber", "BroadcastMonitoringStarted", "BroadcastMonitoringEnded", "BroadcastAdded", "BroadcastRemoved", "SevenTVEmoteAdded", "SevenTVEmoteRemoved", "BetterTTVEmoteAdded", "BetterTTVEmoteRemoved"];
    readonly Pulsoid: readonly ["HeartRatePulse"];
    readonly HypeRate: readonly ["HeartRatePulse", "TwitchClipCreated", "Connected", "Disconnected"];
    readonly Kofi: readonly ["Donation", "Subscription", "Resubscription", "ShopOrder", "Commission"];
    readonly Patreon: readonly ["FollowCreated", "FollowDeleted", "PledgeCreated", "PledgeUpdated", "PledgeDeleted"];
    readonly Application: readonly ["ActionAdded", "ActionUpdated", "ActionDeleted"];
    readonly TipeeeStream: readonly ["Donation"];
    readonly TreatStream: readonly ["Treat", "Authenticated", "Connected", "Disconnected"];
    readonly Shopify: readonly ["OrderCreated", "OrderPaid"];
    readonly Obs: readonly ["Connected", "Disconnected", "Event", "SceneChanged", "StreamingStarted", "StreamingStopped", "RecordingStarted", "RecordingStopped", "VendorEvent"];
    readonly Midi: readonly ["Message"];
    readonly HotKey: readonly ["Press"];
    readonly StreamDeck: readonly ["Action", "Connected", "Disconnected", "Info"];
    readonly Custom: readonly ["Event", "CodeEvent"];
    readonly VTubeStudio: readonly ["ModelLoaded", "ModelUnloaded", "BackgroundChanged", "ModelConfigChanged", "HotkeyTriggered", "ModelAnimation", "Connected", "Disconnected", "TrackingStatusChanged", "ItemEvent", "ModelClicked"];
    readonly CrowdControl: readonly ["GameSessionStart", "GameSessionEnd", "EffectRequest", "EffectSuccess", "EffectFailure", "TimedEffectStarted", "TimedEffectEnded", "TimedEffectUpdated", "CoinExchange"];
    readonly Elgato: readonly ["WaveLinkOutputSwitched", "WaveLinkOutputVolumeChanged", "WaveLinkOutputMuteChanged", "WaveLinkSelectedOutputChanged", "WaveLinkInputVolumeChanged", "WaveLinkInputMuteChanged", "WaveLinkInputNameChanged", "WaveLinkMicrophoneGainChanged", "WaveLinkMicrophoneOutputVolumeChanged", "WaveLinkMicrophoneBalanceChanged", "WaveLinkMicrophoneMuteChanged", "WaveLinkMicrophoneSettingChanged", "WaveLinkFilterAdded", "WaveLinkFilterChanged", "WaveLinkFilterDeleted", "WaveLinkFilterBypassStateChanged", "WaveLinkConnected", "WaveLinkDisconnected", "WaveLinkInputLevelMeterChanged", "WaveLinkOutputLevelMeterChanged", "CameraHubConnected", "CameraHubDisconnected", "CameraHubWebcamConnected", "CameraHubWebcamrDisconnected", "CameraHubWebcamActivated", "CameraHubWebcamDeactivated", "CameraHubSelectedWebcamChanged", "CameraHubWebcamMirrored", "CameraHubWebcamFlipped", "CameraHubWebcamDeviceOrientationChanged", "CameraHubWebcamExposureAutoLockEnabled", "CameraHubWebcamExposureAutoLockDisabled", "CameraHubWebcamSnapshotTaken", "CameraHubWebcamZoomChanged", "CameraHubWebcamContrastChanged", "CameraHubWebcamWhiteBalanceChanged", "CameraHubWebcamAutoExposureEnabled", "CameraHubWebcamAutoExposureDisabled", "CameraHubWebcamAutoWhiteBalanceEnabled", "CameraHubWebcamAutoWhiteBalanceDisabled", "CameraHubWebcamNoiseReductionEnabled", "CameraHubWebcamNoiseReductionDisabled", "CameraHubWebcamISOChanged", "CameraHubWebcamShutterSpeedChanged", "CameraHubWebcamSharpnessChanged", "CameraHubWebcamAntiFlickerChanged", "CameraHubWebcamLensChanged", "CameraHubWebcamARLensChanged", "CameraHubWebcamBitrateChanged", "CameraHubWebcamFlashEnabled", "CameraHubWebcamFlashDisabled", "CameraHubWebcamPanChanged", "CameraHubTiltChanged", "CameraHubWebcamOverscanChanged", "CameraHubWebcamAutoFocusEnabled", "CameraHubWebcamAutoFocusDisabled", "CameraHubWebcamFocusChanged", "CameraHubWebcamWhiteBalanceTintChanged", "CameraHubWebcamBrightnessChanged", "CameraHubWebcamSaturationChanged", "CameraHubWebcamLiveISOChanged", "CameraHubWebcamLiveShutterSpeedChanged", "CameraHubWebcamLiveWhiteBalanceChanged", "CameraHubWebcamLiveWhiteBalanceTintChanged", "CameraHubPrompterConnected", "CameraHubPrompterDisconnected", "CameraHubPrompterModeChanged", "CameraHubPrompterBrightnessChanged", "CameraHubPrompterFontChanged", "CameraHubPrompterFontSizeChanged", "CameraHubPrompterAutoScrollEnabled", "CameraHubPrompterAutoScrollDisabled", "CameraHubPrompterAutoScrollChapterEnabled", "CameraHubPrompterAutoScrollChapterDisabled", "CameraHubPrompterScrollSpeedChanged", "CameraHubPrompterOpacityChanged", "CameraHubPrompterHorizontalMarginChanged", "CameraHubPrompterVerticalMarginChanged", "CameraHubPrompterLineSpacingChanged", "CameraHubPrompterFontColorChanged", "CameraHubPrompterBackgroundColorChanged", "CameraHubPrompterSelectedChapterChanged", "CameraHubPrompterChannelsChanged", "CameraHubPrompterSelectedChannelChanged", "CameraHubPrompterContrastChanged", "CameraHubPrompterCrosshairEnabled", "CameraHubPrompterCrosshairDisabled", "CameraHubPrompterCrosshairImageChanged", "CameraHubPrompterCrosshairColorChanged", "CameraHubPrompterSelectedScriptChanged"];
    readonly StreamlabsDesktop: readonly ["Connected", "Disconnected", "SceneChanged", "StreamingStarted", "StreamingStopped", "RecordingStarted", "RecordingStopped"];
    readonly SpeakerBot: readonly ["Connected", "Disconnected"];
    readonly Fourthwall: readonly ["ProductCreated", "ProductUpdated", "GiftPurchase", "OrderPlaced", "OrderUpdated", "Donation", "SubscriptionPurchased", "SubscriptionExpired", "SubscriptionChanged", "ThankYouSent", "NewsletterSubscribed", "GiftDrawStarted", "GiftDrawEnded"];
    readonly Trovo: readonly ["BroadcasterAuthenticated", "BroadcasterChatConnected", "BroadcasterChatDisconnected", "FirstWords", "PresentViewers", "ChatMessage", "Follow", "SpellCast", "CustomSpellCast", "Raid", "Subscription", "Resubscription", "GiftSubscription", "MassGiftSubscription", "StreamOnline", "StreamOffline"];
    readonly ThrowingSystem: readonly ["Connected", "WebsocketConnected", "WebsocketDisconnected", "EventsConnected", "EventsDisconnected", "ItemHit", "TriggerActivated", "TriggerEnded"];
    readonly Pallygg: readonly ["Connected", "Disconnected", "CampaignTip"];
    readonly StreamerBotRemote: readonly ["InstanceConnected", "InstanceDisconnected", "InstanceTrigger", "InstanceSignal"];
    readonly VoiceMod: readonly ["Connected", "Disconnected", "VoiceLoaded", "SoundboardChanged"];
    readonly Group: readonly ["Added", "Removed", "Cleared", "UsersAdded", "UsersRemoved"];
    readonly MeldStudio: readonly ["Connected", "Disconnected", "StreamingStarted", "StreamingStopped", "RecordingStarted", "RecordingStopped", "SceneChanged", "LayerVisbilityChanged", "LEffectEnabledStateChanged", "TrackMonitoringStateChanged", "TrackMustedStateChanged", "Event"];
};

type TwitchEvents = VerifyEventTypes<'Twitch', {
    AutomaticRewardRedemption: UnknownEventData;
    AutoModMessageHeld: UnknownEventData;
    AutoModMessageUpdate: UnknownEventData;
    BlockedTermsAdded: UnknownEventData;
    AdMidRoll: TwitchAdMidRoll;
    AdRun: TwitchAdRun;
    Announcement: TwitchAnnouncement;
    BetterTTVEmoteAdded: UnknownEventData;
    BetterTTVEmoteRemoved: UnknownEventData;
    BotChatConnected: undefined;
    BotChatDisconnected: undefined;
    BotWhisper: TwitchBotWhisper;
    BroadcasterAuthenticated: undefined;
    BroadcasterChatConnected: undefined;
    BroadcasterChatDisconnected: undefined;
    BroadcasterEventSubConnected: undefined;
    BroadcasterEventSubDisconnected: undefined;
    BroadcasterPubSubConnected: undefined;
    BroadcasterPubSubDisconnected: undefined;
    BroadcastUpdate: UnknownEventData;
    CharityCompleted: TwitchCharityCompleted;
    CharityDonation: TwitchCharityDonation;
    CharityProgress: TwitchCharityProgress;
    CharityStarted: TwitchCharityStarted;
    ChatCleared: TwitchChatCleared;
    ChatEmoteModeOff: undefined;
    ChatEmoteModeOn: undefined;
    ChatFollowerModeChanged: undefined;
    ChatFollowerModeOff: undefined;
    ChatFollowerModeOn: undefined;
    ChatMessage: TwitchChatMessage;
    ChatMessageDeleted: TwitchChatMessageDeleted;
    ChatSlowModeChanged: undefined;
    ChatSlowModeOff: undefined;
    ChatSlowModeOn: undefined;
    ChatSubscriberModeOff: undefined;
    ChatSubscriberModeOn: undefined;
    ChatUniqueModeOff: undefined;
    ChatUniqueModeOn: undefined;
    Cheer: TwitchCheer;
    CoinCheer: UnknownEventData;
    CommunityGoalContribution: TwitchCommunityGoalContribution;
    CommunityGoalEnded: TwitchCommunityGoalEnded;
    FirstWord: TwitchFirstWord;
    Follow: TwitchFollow;
    GiftBomb: undefined;
    GiftSub: TwitchGiftSub;
    GoalBegin: undefined;
    GoalEnd: undefined;
    GoalProgress: UnknownEventData;
    GuestStarGuestUpdate: undefined;
    GuestStarSessionBegin: undefined;
    GuestStarSessionEnd: undefined;
    GuestStarSettingsUpdate: undefined;
    GuestStarSlotUpdate: UnknownEventData;
    HypeChat: UnknownEventData;
    HypeChatLevel: UnknownEventData;
    HypeTrainEnd: TwitchHypeTrainEnd;
    HypeTrainLevelUp: TwitchHypeTrainLevelUp;
    HypeTrainStart: TwitchHypeTrainStart;
    HypeTrainUpdate: TwitchHypeTrainUpdate;
    ModeratorAdded: undefined;
    ModeratorRemoved: undefined;
    PollCompleted: TwitchPollCompleted;
    PollCreated: TwitchPollCreated;
    PollTerminated: undefined;
    PollUpdated: TwitchPollUpdated;
    PredictionCanceled: TwitchPredictionCanceled;
    PredictionCompleted: TwitchPredictionCompleted;
    PredictionCreated: TwitchPredictionCreated;
    PredictionLocked: TwitchPredictionLocked;
    PredictionUpdated: TwitchPredictionUpdated;
    PresentViewers: UnknownEventData;
    PyramidBroken: TwitchPyramidBroken;
    PyramidSuccess: TwitchPyramidSuccess;
    Raid: TwitchRaid;
    RaidCancelled: UnknownEventData;
    RaidSend: UnknownEventData;
    RaidStart: UnknownEventData;
    ReSub: TwitchReSub;
    RewardCreated: TwitchRewardCreated;
    RewardDeleted: TwitchRewardDeleted;
    RewardRedemption: TwitchRewardRedemption;
    RewardRedemptionUpdated: TwitchRewardRedemptionUpdated;
    RewardUpdated: TwitchRewardUpdated;
    SevenTVEmoteAdded: UnknownEventData;
    SevenTVEmoteRemoved: UnknownEventData;
    ShieldModeBegin: TwitchShieldModeBegin;
    ShieldModeEnd: TwitchShieldModeEnd;
    ShoutoutCreated: TwitchShoutoutCreated;
    ShoutoutReceived: undefined;
    StreamOffline: UnknownEventData;
    StreamOnline: UnknownEventData;
    StreamUpdate: TwitchStreamUpdate;
    StreamUpdateGameOnConnect: UnknownEventData;
    Sub: TwitchSub;
    SubCounterRollover: UnknownEventData;
    UnbanRequestApproved: UnknownEventData;
    UnbanRequestCreated: UnknownEventData;
    UnbanRequestDenied: UnknownEventData;
    UpcomingAd: undefined;
    UserBanned: TwitchUserBanned;
    UserUnbanned: UnknownEventData;
    UserTimedOut: TwitchUserTimedOut;
    UserUntimedOut: UnknownEventData;
    ViewerCountUpdate: TwitchViewerCountUpdate;
    VipRemoved: undefined;
    VipAdded: undefined;
    Whisper: TwitchWhisper;
    BlockedTermsDeleted: UnknownEventData;
    WarnedUser: UnknownEventData;
    SuspiciousUserUpdate: UnknownEventData;
    PermittedTermsAdded: UnknownEventData;
    PermittedTermsDeleted: UnknownEventData;
    WarningAcknowledged: UnknownEventData;
    WatchStreak: UnknownEventData;
    PollArchived: UnknownEventData;
    SharedChatSessionBegin: UnknownEventData;
    SharedChatSessionUpdate: UnknownEventData;
    SharedChatSessionEnd: UnknownEventData;
    PrimePaidUpgrade: UnknownEventData;
    PayItForward: UnknownEventData;
    GiftPaidUpgrade: UnknownEventData;
    BitsBadgeTier: UnknownEventData;
    SharedAnnouncement: UnknownEventData;
    SharedRaid: UnknownEventData;
    SharedPrimePaidUpgrade: UnknownEventData;
    SharedGiftPaidUpgrade: UnknownEventData;
    SharedPayItForward: UnknownEventData;
    SharedSub: UnknownEventData;
    SharedResub: UnknownEventData;
    SharedSubGift: UnknownEventData;
    SharedCommunitySubGift: UnknownEventData;
}>;
type TwitchEmote = {
    bits: number;
    color: string;
    type: string;
    name: string;
    startIndex: number;
    endIndex: number;
    imageUrl: string;
};
type TwitchBadge = {
    name: string;
    version: string;
    imageUrl: string;
};
type TwitchFollow = {
    user_id: string;
    user_login: string;
    user_name: string;
    followed_at: string;
};
type TwitchCheer = {
    internal: boolean;
    msgId: string;
    userId: string;
    username: string;
    role: number;
    subscriber: boolean;
    displayName: string;
    channel: string;
    message: string;
    isHighlighted: boolean;
    isMe: boolean;
    isCustomReward: boolean;
    isAnonymous: boolean;
    isReply: boolean;
    bits: number;
    firstMessage: boolean;
    hasBits: boolean;
    emotes: Array<TwitchEmote>;
    cheerEmotes: Array<TwitchEmote>;
    badges: Array<TwitchBadge>;
    monthsSubscribed: number;
    isTest: boolean;
};
type TwitchRaid = {
    from_broadcaster_user_id: string;
    from_broadcaster_user_login: string;
    from_broadcaster_user_name: string;
    to_broadcaster_user_id: string;
    to_broadcaster_user_login: string;
    to_broadcaster_user_name: string;
    viewers: number;
};
type TwitchStreamUpdate = {
    channelId: string;
    channel: string;
    status: string;
    oldStatus: string;
    oldGame: {
        id: string;
        name: string;
    };
    game: {
        id: string;
        name: string;
    };
};
type TwitchWhisper = {
    message: {
        msgId: string;
        userId: string;
        username: string;
        displayName: string;
        message: string;
        emotes: Array<TwitchEmote>;
        badges: Array<TwitchBadge>;
    };
};
type TwitchBotWhisper = {
    message: {
        msgId: string;
        userId: string;
        username: string;
        displayName: string;
        message: string;
        emotes: Array<TwitchEmote>;
        badges: Array<TwitchBadge>;
    };
};
type TwitchFirstWord = {
    message: {
        internal: boolean;
        msgId: string;
        userId: string;
        username: string;
        role: number;
        subscriber: boolean;
        displayName: string;
        color: string;
        channel: string;
        message: string;
        isHighlighted: boolean;
        isMe: boolean;
        isCustomReward: boolean;
        isAnonymous: boolean;
        isReply: boolean;
        bits: number;
        firstMessage: boolean;
        hasBits: boolean;
        emotes: Array<TwitchEmote>;
        cheerEmotes: Array<TwitchEmote>;
        badges: Array<TwitchBadge>;
        monthsSubscribed: number;
        isTest: boolean;
    };
};
type TwitchChatMessage = {
    message: {
        internal: boolean;
        msgId: string;
        userId: string;
        username: string;
        role: number;
        subscriber: boolean;
        displayName: string;
        color: string;
        channel: string;
        message: string;
        isHighlighted: boolean;
        isMe: boolean;
        isCustomReward: boolean;
        isAnonymous: boolean;
        isReply: boolean;
        bits: number;
        firstMessage: boolean;
        hasBits: boolean;
        emotes: Array<TwitchEmote>;
        cheerEmotes: Array<any>;
        badges: Array<TwitchBadge>;
        monthsSubscribed: number;
        isTest: boolean;
    };
};
type TwitchAdRun = {
    length_seconds: number;
    timestamp: string;
    is_automatic: boolean;
    requester_user_id: string;
    requester_user_login: string;
    requester_user_name: string;
};
type TwitchAdMidRoll = {
    type: string;
    jitterTime: number;
    warmupTime: number;
    commercialId: string;
};
type TwitchSub = {
    subTier: number;
    emotes: Array<any>;
    badges: Array<any>;
    message: string;
    userId: string;
    userName: string;
    displayName: string;
    role: number;
    isTest: boolean;
};
type TwitchReSub = {
    cumulativeMonths: number;
    shareStreak: boolean;
    streakMonths: number;
    subTier: number;
    emotes: Array<any>;
    badges: Array<any>;
    message: string;
    userId: string;
    userName: string;
    displayName: string;
    role: number;
    isTest: boolean;
};
type TwitchGiftSub = {
    isAnonymous: boolean;
    totalSubsGifted: number;
    cumulativeMonths: number;
    monthsGifted: number;
    fromSubBomb: boolean;
    subBombCount: number;
    recipientUserId: string;
    recipientUsername: string;
    recipientDisplayName: string;
    subTier: number;
    emotes: Array<any>;
    badges: Array<any>;
    userId: string;
    userName: string;
    displayName: string;
    role: number;
    isTest: boolean;
};
type TwitchHypeTrainStart = {
    level: number;
    progress: number;
    last_contribution: {
        user_id: string;
        user_login: string;
        user_name: string;
        total: number;
    };
    expires_at: string;
    isTest: boolean;
    id: string;
    total: number;
    goal: number;
    top_contributions: Array<{
        user_id: string;
        user_login: string;
        user_name: string;
        type: string;
        total: number;
    }>;
    started_at: string;
};
type TwitchHypeTrainUpdate = {
    level: number;
    progress: number;
    last_contribution: {
        user_id: string;
        user_login: string;
        user_name: string;
        total: number;
    };
    expires_at: string;
    isTest: boolean;
    id: string;
    total: number;
    goal: number;
    top_contributions: Array<{
        user_id: string;
        user_login: string;
        user_name: string;
        type: string;
        total: number;
    }>;
    started_at: string;
};
type TwitchHypeTrainLevelUp = {
    level: number;
    progress: number;
    last_contribution: {
        user_id: string;
        user_login: string;
        user_name: string;
        total: number;
    };
    expires_at: string;
    isTest: boolean;
    id: string;
    total: number;
    goal: number;
    top_contributions: Array<{
        user_id: string;
        user_login: string;
        user_name: string;
        type: string;
        total: number;
    }>;
    started_at: string;
};
type TwitchHypeTrainEnd = {
    level: number;
    ended_at: string;
    cooldown_ends_at: string;
    isTest: boolean;
    id: string;
    total: number;
    goal: number;
    top_contributions: Array<{
        user_id: string;
        user_login: string;
        user_name: string;
        type: string;
        total: number;
    }>;
    started_at: string;
};
type TwitchRewardRedemption = {
    id: string;
    user_id: string;
    user_login: string;
    user_name: string;
    user_input: string;
    status: string;
    reward: {
        id: string;
        title: string;
        cost: number;
        prompt: string;
    };
    redeemed_at: string;
};
type TwitchRewardRedemptionUpdated = {
    id: string;
    user_id: string;
    user_login: string;
    user_name: string;
    user_input: string;
    status: string;
    reward: {
        id: string;
        title: string;
        cost: number;
        prompt: string;
    };
    redeemed_at: string;
};
type TwitchRewardCreated = {
    id: string;
    name: string;
    prompt: string;
    group: string;
    cost: number;
    userInput: boolean;
    persistCounter: boolean;
    persistUserCounter: boolean;
    backgroundColor: string;
};
type TwitchRewardUpdated = {
    id: string;
    is_enabled: boolean;
    is_paused: boolean;
    is_in_stock: boolean;
    title: string;
    cost: number;
    prompt: string;
    is_user_input_required: boolean;
    should_redemptions_skip_request_queue: boolean;
    cooldown_expires_at: string;
    max_per_stream: {
        is_enabled: boolean;
        value: number;
    };
    max_per_user_per_stream: {
        is_enabled: boolean;
        value: number;
    };
    global_cooldown: {
        is_enabled: boolean;
        seconds: number;
    };
    background_color: string;
    default_image: {
        url_1x: string;
        url_2x: string;
        url_4x: string;
    };
};
type TwitchRewardDeleted = {
    id: string;
    is_enabled: boolean;
    is_paused: boolean;
    is_in_stock: boolean;
    title: string;
    cost: number;
    prompt: string;
    is_user_input_required: boolean;
    should_redemptions_skip_request_queue: boolean;
    max_per_stream: {
        is_enabled: boolean;
        value: number;
    };
    max_per_user_per_stream: {
        is_enabled: boolean;
        value: number;
    };
    global_cooldown: {
        is_enabled: boolean;
        seconds: number;
    };
    background_color: string;
    default_image: {
        url_1x: string;
        url_2x: string;
        url_4x: string;
    };
};
type TwitchCommunityGoalContribution = {
    dateTime: string;
    channelId: string;
    id: string;
    title: string;
    description: string;
    inStock: boolean;
    amount: number;
    contributed: number;
    duration: number;
    startedAt: string;
    endsAt: string;
    daysLeft: number;
    userId: string;
    userName: string;
    displayName: string;
    userContributed: number;
    userStreamContributed: number;
    userTotalContributed: number;
    isTest: boolean;
};
type TwitchCommunityGoalEnded = {
    userId: string;
    userName: string;
    displayName: string;
    dateTime: string;
    channelId: string;
    id: string;
    title: string;
    description: string;
    inStock: boolean;
    amount: number;
    contributed: number;
    duration: number;
    isTest: boolean;
};
type TwitchPollCreated = {
    ends_at: string;
    id: string;
    title: string;
    choices: Array<{
        id: string;
        title: string;
        channel_points_votes: number;
        votes: number;
    }>;
    channel_points_voting: {
        is_enabled: boolean;
        amount_per_vote: number;
    };
    started_at: string;
};
type TwitchPollUpdated = {
    ends_at: string;
    id: string;
    title: string;
    choices: Array<{
        id: string;
        title: string;
        channel_points_votes: number;
        votes: number;
    }>;
    channel_points_voting: {
        is_enabled: boolean;
        amount_per_vote: number;
    };
    started_at: string;
};
type TwitchPollCompleted = {
    status: string;
    ended_at: string;
    winningChoice: {
        id: string;
        title: string;
        channel_points_votes: number;
        votes: number;
    };
    id: string;
    title: string;
    choices: Array<{
        id: string;
        title: string;
        channel_points_votes: number;
        votes: number;
    }>;
    channel_points_voting: {
        is_enabled: boolean;
        amount_per_vote: number;
    };
    started_at: string;
};
type TwitchPredictionCreated = {
    locks_at: string;
    id: string;
    title: string;
    outcomes: Array<{
        id: string;
        title: string;
        color: string;
        users: number;
        channel_points: number;
    }>;
    started_at: string;
};
type TwitchPredictionUpdated = {
    locks_at: string;
    id: string;
    title: string;
    outcomes: Array<{
        id: string;
        title: string;
        color: string;
        users: number;
        channel_points: number;
        top_predictors: Array<{
            user_id: string;
            user_login: string;
            user_name: string;
            channel_points_used: number;
        }>;
    }>;
    started_at: string;
};
type TwitchPredictionCompleted = {
    winning_outcome_id: string;
    status: string;
    ended_at: string;
    winning_outcome: {
        id: string;
        title: string;
        color: string;
        users: number;
        channel_points: number;
        top_predictors: Array<{
            user_id: string;
            user_login: string;
            user_name: string;
            channel_points_won: number;
            channel_points_used: number;
        }>;
    };
    id: string;
    title: string;
    outcomes: Array<{
        id: string;
        title: string;
        color: string;
        users: number;
        channel_points: number;
        top_predictors: Array<{
            user_id: string;
            user_login: string;
            user_name: string;
            channel_points_won: number;
            channel_points_used: number;
        }>;
    }>;
    started_at: string;
};
type TwitchPredictionCanceled = {
    winning_outcome_id: string;
    status: string;
    ended_at: string;
    id: string;
    title: string;
    outcomes: Array<{
        id: string;
        title: string;
        color: string;
        users: number;
        channel_points: number;
        top_predictors: Array<{
            user_id: string;
            user_login: string;
            user_name: string;
            channel_points_used: number;
        }>;
    }>;
    started_at: string;
};
type TwitchPredictionLocked = {
    locked_at: string;
    id: string;
    title: string;
    outcomes: Array<{
        id: string;
        title: string;
        color: string;
        users: number;
        channel_points: number;
        top_predictors: Array<{
            user_id: string;
            user_login: string;
            user_name: string;
            channel_points_used: number;
        }>;
    }>;
    started_at: string;
};
type TwitchViewerCountUpdate = {
    viewers: number;
};
type TwitchCharityStarted = {
    id: string;
    current_amount: {
        value: number;
        decimal_places: number;
        currency: string;
    };
    target_amount: {
        value: number;
        decimal_places: number;
        currency: string;
    };
    started_at: string;
    charity_name: string;
    charity_description: string;
    charity_logo: string;
    charity_website: string;
};
type TwitchCharityDonation = {
    id: string;
    campaign_id: string;
    user_id: string;
    user_login: string;
    user_name: string;
    amount: {
        value: number;
        decimal_places: number;
        currency: string;
    };
    charity_name: string;
};
type TwitchCharityProgress = {
    id: string;
    current_amount: {
        value: number;
        decimal_places: number;
        currency: string;
    };
    target_amount: {
        value: number;
        decimal_places: number;
        currency: string;
    };
    charity_name: string;
    charity_description: string;
    charity_logo: string;
    charity_website: string;
};
type TwitchCharityCompleted = {
    id: string;
    current_amount: {
        value: number;
        decimal_places: number;
        currency: string;
    };
    target_amount: {
        value: number;
        decimal_places: number;
        currency: string;
    };
    stopped_at: string;
    charity_name: string;
    charity_description: string;
    charity_logo: string;
    charity_website: string;
};
type TwitchAnnouncement = {
    msgId: string;
    subscriber: boolean;
    color: string;
    message: string;
    emotes: Array<{
        id: string;
        type: string;
        name: string;
        startIndex: number;
        endIndex: number;
        imageUrl: string;
    }>;
    badges: Array<{
        name: string;
        version: string;
        imageUrl: string;
    }>;
    monthsSubscribed: number;
    announcementColor: string;
    userId: string;
    userName: string;
    displayName: string;
    role: number;
    isTest: boolean;
};
type TwitchPyramidBroken = {
    ownerId: string;
    ownerUsername: string;
    ownerDisplay: string;
    total: number;
    width: number;
    emote: string;
    user: {
        display: string;
        id: string;
        name: string;
        role: number;
        subscribed: boolean;
        type: string;
    };
};
type TwitchPyramidSuccess = {
    total: number;
    width: number;
    emote: string;
    user: {
        display: string;
        id: string;
        name: string;
        role: number;
        subscribed: boolean;
        type: string;
    };
};
type TwitchChatCleared = {
    target_user_id: string;
    target_user_login: string;
    created_by_user_id: string;
    created_by: string;
    moderation_action: string;
    type: string;
    duration: number;
    isTest: boolean;
};
type TwitchChatMessageDeleted = {
    targetMessageId: string;
    message: string;
    userName: string;
    role: number;
    isTest: boolean;
};
type TwitchShieldModeBegin = {
    moderator_user_id: string;
    moderator_user_name: string;
    moderator_user_login: string;
    started_at: string;
};
type TwitchShieldModeEnd = {
    moderator_user_id: string;
    moderator_user_name: string;
    moderator_user_login: string;
    ended_at: string;
};
type TwitchShoutoutCreated = {
    moderator_user_id: string;
    moderator_user_name: string;
    moderator_user_login: string;
    to_broadcaster_user_id: string;
    to_broadcaster_user_login: string;
    to_broadcaster_user_name: string;
    viewer_count: number;
    started_at: string;
    cooldown_ends_at: string;
    target_cooldown_ends_at: string;
};
type TwitchUserTimedOut = {
    target_user_display: string;
    target_user_id: string;
    target_user_login: string;
    created_at: string;
    created_by_user_id: string;
    created_by: string;
    moderation_action: string;
    type: string;
    duration: number;
    reason: string;
    isTest: boolean;
};
type TwitchUserBanned = {
    target_user_display: string;
    target_user_id: string;
    target_user_login: string;
    created_at: string;
    created_by_user_id: string;
    created_by: string;
    moderation_action: string;
    type: string;
    duration: number;
    reason: string;
    isTest: boolean;
};

/**
 * Prettify hover overlays
 */
type Prettify<T> = {
    [K in keyof T]: T[K];
} & {};
/**
 * Recursively makes all properties of an object writable.
 */
type DeepWriteable<T> = {
    -readonly [P in keyof T]: DeepWriteable<T[P]>;
};
/**
 * Matches a JSON object
 *
 * @link https://github.com/sindresorhus/type-fest?tab=readme-ov-file#json
 */
type JsonObject = {
    [Key in string]: JsonValue;
} & {
    [Key in string]?: JsonValue | undefined;
};
/**
 * Matches a JSON array
 *
 * @link https://github.com/sindresorhus/type-fest?tab=readme-ov-file#json
 */
type JsonArray = JsonValue[] | readonly JsonValue[];
/**
 * Matches a JSON primitive
 *
 * @link https://github.com/sindresorhus/type-fest?tab=readme-ov-file#json
 */
type JsonPrimitive = string | number | boolean | null;
/**
 * Matches any valid JSON value
 *
 * @link https://github.com/sindresorhus/type-fest?tab=readme-ov-file#json
 */
type JsonValue = JsonPrimitive | JsonObject | JsonArray;

type StreamerbotEventsType = typeof StreamerbotEvents;
type StreamerbotEventsTypeWriteable = DeepWriteable<StreamerbotEventsType>;
type StreamerbotEventSource = keyof typeof StreamerbotEvents;
type StreamerbotEventType<TSource = StreamerbotEventSource> = StreamerbotEventsType[TSource extends StreamerbotEventSource ? TSource : StreamerbotEventSource][number];
type StreamerbotEventSourceValue<T extends StreamerbotEventSource> = T extends StreamerbotEventSource ? `${T}.${StreamerbotEventsType[T][number] | '*'}` : string;
type StreamerbotEventName = `${StreamerbotEventSourceValue<StreamerbotEventSource>}`;
type StreamerbotEventsSubscriptionType<T extends StreamerbotEventSource> = T extends StreamerbotEventSource ? Array<StreamerbotEventsType[T][number]> : string[];
type StreamerbotEventsSubscription = Partial<{
    [P in StreamerbotEventSource]: StreamerbotEventsSubscriptionType<P>;
}>;
type StreamerbotEventPayload<TEvent extends StreamerbotEventName> = (TEvent extends `${infer Source extends StreamerbotEventSource}.${infer Type extends StreamerbotEventType | '*'}` ? Type extends StreamerbotEventType ? {
    event: {
        source: Source;
        type: Type;
    };
    data: StreamerbotEventsBySource[Source][Type];
} : {
    event: {
        source: Source;
        type: StreamerbotEventType<Source>;
    };
    data: StreamerbotEventsBySource[Source][StreamerbotEventType<Source>];
} : {
    event: {
        source: string;
        type: string;
    };
    data: unknown;
}) & {
    timeStamp: string;
};
type StreamerbotEventData<TEvent extends StreamerbotEventName> = TEvent extends `${infer Source extends StreamerbotEventSource}.${infer Type extends StreamerbotEventType | '*'}` ? Type extends '*' ? StreamerbotEventsBySource[Source][StreamerbotEventType<Source>] : StreamerbotEventsBySource[Source][Type] : unknown;
/**
 * Fallback type for unknown Streamer.bot event data
 */
type UnknownEventData = JsonObject | undefined;
/**
 * All possible Streamer.bot events indexed by source and type
 */
type StreamerbotEventsBySource = VerifyEventSources<{
    Application: any;
    Command: any;
    CrowdControl: any;
    Custom: any;
    DonorDrive: any;
    Elgato: any;
    FileTail: any;
    FileWatcher: any;
    Fourthwall: any;
    General: any;
    Group: any;
    HotKey: any;
    HypeRate: any;
    Kofi: any;
    MeldStudio: any;
    Midi: any;
    Misc: any;
    Obs: any;
    Pallygg: any;
    Patreon: any;
    Pulsoid: any;
    Quote: any;
    Raw: any;
    Shopify: any;
    SpeakerBot: any;
    SpeechToText: any;
    StreamDeck: any;
    StreamElements: any;
    StreamerBotRemote: any;
    Streamlabs: any;
    StreamlabsDesktop: any;
    ThrowingSystem: any;
    TipeeeStream: any;
    TreatStream: any;
    Trovo: any;
    Twitch: TwitchEvents;
    VoiceMod: any;
    VStream: any;
    VTubeStudio: any;
    WebsocketClient: any;
    WebsocketCustomServer: any;
    YouTube: any;
}>;
/**
 * Type guard for Streamer.bot event sources
 *
 * This will check that all Streamer.bot event sources are defined as types
 */
type EventSourceGuard<TSource extends StreamerbotEventSource> = Record<TSource, EventTypeGuard<TSource> | unknown>;
type VerifyEventSources<T extends EventSourceGuard<StreamerbotEventSource> & {
    [U in Exclude<keyof T, StreamerbotEventType>]: unknown;
}> = T;
/**
 * Type guard for Streamer.bot event types
 *
 * This will check that all possible event types are defined within a given event source
 */
type EventTypeGuard<TSource> = Record<StreamerbotEventType<TSource>, JsonObject | undefined>;
type VerifyEventTypes<TSource, T extends EventTypeGuard<TSource> & {
    [U in Exclude<keyof T, StreamerbotEventType<TSource>>]: never;
}> = T;

type StreamerbotInfo = {
    /**
     * The ID of the connected Streamer.bot instance
     *
     * @example 'b63152c5-5bfe-4751-8644-579f7fb4a682'
     */
    instanceId: string;
    /**
     * The name of the connected Streamer.bot instance
     *
     * @example 'Streamer.bot'
     */
    name: string;
    /**
     * The operating system of the connected Streamer.bot instance
     *
     * @example 'windows'
     */
    os: 'windows' | 'linux' | 'macosx' | (string & {});
    /**
     * The version of the operating system of the connected Streamer.bot instance
     *
     * @example '10.0.0.19042'
     * @version 0.2.5
     */
    osVersion: string;
    /**
     * The version of the connected Streamer.bot instance
     *
     * @example '0.1.21'
     */
    version: string;
    /**
     * The source of the Streamer.bot connection
     * @description Requires Streamer.bot v0.1.21 or higher
     */
    source?: 'websocketServer' | 'streamDeckServer' | 'httpServer' | (string & {});
};

type StreamerbotCommand = {
    id: string;
    enabled: boolean;
    name: string;
    group: string;
    commands: Array<string>;
    caseSensitive: boolean;
    ignoreInternal: boolean;
    ignoreBotAccount: boolean;
    sources: Array<string>;
};

type StreamerbotGlobalVariableName = string;
type StreamerbotVariableValue = string | number | boolean | null;
type StreamerbotGlobalVariable<T extends StreamerbotVariableValue = StreamerbotVariableValue, K extends string = string> = {
    name: K;
    value: T;
    lastWrite: string;
};
type StreamerbotUserGlobalVariable<T extends StreamerbotVariableValue = StreamerbotVariableValue, K extends string = string, U = string, P = StreamerbotPlatform> = StreamerbotGlobalVariable<T, K> & {
    userId: U;
    userLogin: string;
    userName: string;
    platform: P;
};

type StreamerbotUserPronouns = {
    pronouns: string;
    pronounSubject: string;
    pronounObject: string;
    pronounPossessive: string;
    pronounPronoun: string;
    pronounReflexive: string;
    pronounPastTense: string;
    pronounSubjectLower: string;
    pronounObjectLower: string;
    pronounPossessiveLower: string;
    pronounPronounLower: string;
    pronounReflexiveLower: string;
    pronounPastTenseLower: string;
    pronounCurrentTense: string;
    pronounCurrentTenseLower: string;
    pronounPluralLower: string;
    pronounLastCached: string;
    userFound: boolean;
};

type StreamerbotViewer = {
    channelPointsUsed: number;
    display: string;
    exempt: boolean;
    groups: Array<string>;
    id: string | number;
    login: string;
    previousActive: string;
    role: string;
    subscribed: boolean;
};

type StreamerbotResponse<T, TStatus = 'ok' | 'error'> = T & {
    id: string;
    status: TStatus;
};
type StreamerbotOkResponse<T> = StreamerbotResponse<T, 'ok'>;
type StreamerbotErrorResponse = StreamerbotResponse<{
    error: string;
}, 'error'>;
type MaybeStreamerbotResponse<T> = StreamerbotOkResponse<T> | StreamerbotErrorResponse;
type SubscribeResponse = StreamerbotResponse<{
    events: StreamerbotEventsSubscription;
}>;
type UnsubscribeResponse = StreamerbotResponse<{
    events: StreamerbotEventsSubscription;
}>;
type GetEventsResponse = StreamerbotResponse<{
    events: StreamerbotEventsType;
}>;
type GetActionsResponse = StreamerbotResponse<{
    actions: Array<StreamerbotAction>;
    count: number;
}>;
type DoActionResponse = StreamerbotResponse<{}>;
type GetBroadcasterResponse = StreamerbotResponse<{
    platforms: Partial<BroadcasterPlatforms>;
    connected: Array<BroadcasterPlatform>;
    disconnected: Array<BroadcasterPlatform>;
}>;
type GetMonitoredYouTubeBroadcastsResponse = StreamerbotResponse<{
    broadcasts: Array<MonitoredYouTubeBroadcast>;
    count: number;
}>;
type GetCreditsResponse = StreamerbotResponse<StreamerbotCredits>;
type TestCreditsResponse = StreamerbotResponse<StreamerbotCredits>;
type ClearCreditsResponse = StreamerbotResponse<{}>;
type GetInfoResponse = StreamerbotResponse<{
    info: StreamerbotInfo;
}>;
type GetActiveViewersResponse = StreamerbotResponse<{
    viewers: Array<StreamerbotViewer>;
    count: number;
}>;
type ExecuteCodeTriggerResponse = StreamerbotResponse<unknown>;
type GetCodeTriggersResponse = StreamerbotResponse<{
    triggers: Array<{
        name: string;
        eventName: string;
        category: string;
    }>;
    count: number;
}>;
type GetCommandsResponse = StreamerbotResponse<{
    commands: Array<StreamerbotCommand>;
    count: number;
}>;
type TwitchGetEmotesResponse = StreamerbotResponse<{
    emotes: {
        userEmotes: Array<Emote>;
        bttvEmotes: Array<Emote>;
        ffzEmotes: Array<Emote>;
        sevenTvEmotes: Array<Emote>;
    };
}>;
type YouTubeGetEmotesResponse = StreamerbotResponse<{
    emotes: {
        userEmotes: Array<Emote>;
        bttvEmotes: Array<Emote>;
        sevenTvEmotes: Array<Emote>;
    };
}>;
type GetGlobalsResponse = StreamerbotResponse<{
    variables: Record<StreamerbotGlobalVariableName, StreamerbotGlobalVariable>;
    count: number;
}>;
type GetGlobalResponse<T extends StreamerbotVariableValue, K extends string = string> = MaybeStreamerbotResponse<{
    variables: Record<K, Prettify<StreamerbotGlobalVariable<T, K>>>;
    count: number;
}>;
type GetUserGlobalsResponse<T extends StreamerbotVariableValue = StreamerbotVariableValue, K extends string = string, P = StreamerbotPlatform> = StreamerbotResponse<{
    variables: StreamerbotUserGlobalVariable<T, K, string, P>[];
    count: number;
}>;
type GetUserGlobalResponse<T extends StreamerbotVariableValue = StreamerbotVariableValue, K extends string = string> = MaybeStreamerbotResponse<{
    variables: StreamerbotGlobalVariable<T, K>[];
    count: number;
}>;
type SendMessageResponse = MaybeStreamerbotResponse<{}>;
type GetUserPronounsResponse = MaybeStreamerbotResponse<{
    userLogin: string;
    pronoun: StreamerbotUserPronouns;
}>;
type StreamerbotResponseTypes = StreamerbotResponse<unknown> | SubscribeResponse | UnsubscribeResponse | GetEventsResponse | GetActionsResponse | DoActionResponse | GetBroadcasterResponse | GetMonitoredYouTubeBroadcastsResponse | GetCreditsResponse | TestCreditsResponse | ClearCreditsResponse | GetInfoResponse | GetActiveViewersResponse | ExecuteCodeTriggerResponse | GetCodeTriggersResponse | GetCommandsResponse | TwitchGetEmotesResponse | YouTubeGetEmotesResponse | GetGlobalsResponse | GetGlobalResponse<StreamerbotVariableValue> | GetUserGlobalsResponse | GetUserGlobalResponse | SendMessageResponse | GetUserPronounsResponse;

type WebSocketStatus = 'OPEN' | 'CONNECTING' | 'CLOSED';

type StreamerbotRequestName = 'Authenticate' | 'Subscribe' | 'UnSubscribe' | 'GetEvents' | 'GetActions' | 'DoAction' | 'GetBroadcaster' | 'GetMonitoredYouTubeBroadcasts' | 'GetCredits' | 'TestCredits' | 'ClearCredits' | 'GetInfo' | 'GetActiveViewers' | 'ExecuteCodeTrigger' | 'GetCodeTriggers' | 'GetCommands' | 'TwitchGetEmotes' | 'YouTubeGetEmotes' | 'GetGlobals' | 'GetGlobal' | 'TwitchGetUserGlobals' | 'TwitchGetUserGlobal' | 'YouTubeGetUserGlobals' | 'YouTubeGetUserGlobal' | 'TrovoGetUserGlobals' | 'TrovoGetUserGlobal' | 'SendMessage' | 'GetUserPronouns';
type StreamerbotRequest = {
    request: StreamerbotRequestName;
    [key: string]: any;
};

type StreamerbotClientOptions = {
    scheme: 'ws' | 'wss' | string;
    host: string;
    port: number;
    endpoint: string;
    password?: string;
    immediate: boolean;
    autoReconnect: boolean;
    retries: number;
    subscribe: StreamerbotEventsSubscription | '*';
    onConnect?: (data: StreamerbotInfo) => void;
    onDisconnect?: () => void;
    onError?: (error: Error) => void;
    onData?: (data: any) => void;
};
declare const DefaultStreamerbotClientOptions: StreamerbotClientOptions;
/**
 * The `StreamerbotClient` class provides an interface to connect and interact with a Streamer.bot WebSocket server.
 * It allows for authentication, event subscription, and various requests to control and retrieve information from the Streamer.bot instance.
 *
 * @example
 * ```typescript
 * const client = new StreamerbotClient({
 *   host: 'localhost',
 *   port: 8080,
 *   password: 'your_password',
 *   immediate: true,
 *   autoReconnect: true,
 *   retries: 5,
 *   onConnect: (info) => console.log('Connected to Streamer.bot', info),
 *   onError: (error) => console.error('Error:', error),
 * });
 *
 * client.on('Twitch.ChatMessage', (data) => {
 *   console.log('Chat message received:', data);
 * });
 * ```
 *
 * @remarks
 * The client supports both browser and Node.js environments. In a Node.js environment, it uses the `ws` package for WebSocket connections.
 *
 * @param options - Configuration options for the StreamerbotClient instance.
 * @param options.host - The host of the Streamer.bot WebSocket server.
 * @param options.port - The port of the Streamer.bot WebSocket server.
 * @param options.password - The password for authentication with the Streamer.bot WebSocket server.
 * @param options.scheme - The scheme to use for the WebSocket connection (e.g., 'ws' or 'wss').
 * @param options.endpoint - The endpoint path for the WebSocket connection.
 * @param options.immediate - Whether to immediately connect to the WebSocket server upon instantiation.
 * @param options.autoReconnect - Whether to automatically reconnect to the WebSocket server if the connection is lost.
 * @param options.retries - The number of reconnection attempts before giving up. A negative value means infinite retries.
 * @param options.subscribe - Initial subscriptions to events upon connection.
 * @param options.onConnect - Callback function to be called when the client successfully connects to the WebSocket server.
 * @param options.onDisconnect - Callback function to be called when the client disconnects from the WebSocket server.
 * @param options.onError - Callback function to be called when an error occurs.
 * @param options.onData - Callback function to be called when data is received from the WebSocket server.
 *
 * @public
 */
declare class StreamerbotClient {
    private readonly options;
    protected socket?: WebSocket | WebSocket$1;
    protected info?: StreamerbotInfo;
    protected version?: string;
    private _authEnabled;
    private _authenticated;
    private listeners;
    private subscriptions;
    private _explicitlyClosed;
    private _retried;
    private _connectController;
    private _reconnectTimeout;
    constructor(options?: Partial<StreamerbotClientOptions>);
    /**
     * Check if the WebSocket connection is authenticated
     */
    get authenticated(): boolean;
    /**
     * Connect to a Streamer.bot WebSocket server
     */
    connect(timeout?: number): Promise<void>;
    /**
     * Disconnect Streamer.bot WebSocket
     */
    disconnect(code?: number, timeout?: number): Promise<void>;
    private handshake;
    private authenticate;
    protected onOpen(): Promise<void>;
    protected onClose(event: CloseEvent): void;
    protected onMessage(event: MessageEvent): Promise<void>;
    protected onError(event: Event): void;
    protected cleanup(): void;
    /**
     * Send a raw object to the Streamer.bot WebSocket
     */
    send(data: Object): void;
    /**
     * Make a request to the Streamer.bot WebSocket,
     * wait for the response, and return the response data
     */
    request<T extends StreamerbotResponseTypes>(request: StreamerbotRequest, id?: string, timeout?: number): Promise<T>;
    /**
     * Listener for specific event data
     */
    on<TEvent>(event: TEvent extends StreamerbotEventName ? TEvent : StreamerbotEventName | '*', listener: (data: StreamerbotEventPayload<TEvent extends StreamerbotEventName ? TEvent : StreamerbotEventName>) => void): Promise<void>;
    /**
     * Subscribe to events from your connected Streamer.bot instance
     */
    subscribe(events: StreamerbotEventsSubscription | '*'): Promise<SubscribeResponse>;
    /**
     * Unsubscribe from events you are currently subscribed to
     */
    unsubscribe(events: StreamerbotEventsSubscription | '*'): Promise<UnsubscribeResponse>;
    /**
     * Get all possible events that may be subscribed to
     */
    getEvents(): Promise<GetEventsResponse>;
    /**
     * Get all actions from your connected Streamer.bot instance
     */
    getActions(): Promise<GetActionsResponse>;
    /**
     * Get all actions from your connected Streamer.bot instance
     */
    doAction(action: string | Partial<Pick<StreamerbotAction, 'id' | 'name'>>, args?: Record<string, any>): Promise<DoActionResponse>;
    /**
     * Get the current broadcaster account information
     */
    getBroadcaster(): Promise<GetBroadcasterResponse>;
    /**
     * Get all monitored YouTube broadcasts
     *
     * @version 0.2.5
     */
    getMonitoredYouTubeBroadcasts(): Promise<GetMonitoredYouTubeBroadcastsResponse>;
    /**
     * Get the current credits payload
     */
    getCredits(): Promise<GetCreditsResponse>;
    /**
     * Test credits by populating with fake data
     */
    testCredits(): Promise<TestCreditsResponse>;
    /**
     * Reset credits data
     */
    clearCredits(): Promise<ClearCreditsResponse>;
    /**
     * Get information about the connected Streamer.bot instance
     */
    getInfo(): Promise<GetInfoResponse>;
    /**
     * Returns all active viewers and their user information
     */
    getActiveViewers(): Promise<GetActiveViewersResponse>;
    /**
     * Execute a custom code trigger
     */
    executeCodeTrigger(triggerName: string, args?: Record<string, any>): Promise<ExecuteCodeTriggerResponse>;
    /**
     * Get all custom code triggers
     */
    getCodeTriggers(): Promise<GetCodeTriggersResponse>;
    /**
     * Get commands for the connected Streamer.bot instance
     *
     * @version 0.2.5
     */
    getCommands(): Promise<GetCommandsResponse>;
    /**
     * Get emotes for the selected platform
     *
     * @version 0.2.5
     */
    getEmotes(platform: StreamerbotPlatform): Promise<TwitchGetEmotesResponse | YouTubeGetEmotesResponse>;
    /**
     * Get all global variables
     *
     * @version 0.2.5
     */
    getGlobals(persisted?: boolean): Promise<GetGlobalsResponse>;
    /**
     * Get a global variable by name
     *
     * @version 0.2.5
     * @param name The name of the global variable to fetch
     * @param persisted Whether the global variable is persisted
     */
    getGlobal<T extends StreamerbotVariableValue, K extends string = string>(name: K, persisted?: boolean): Promise<StreamerbotErrorResponse | {
        status: string;
        error: string;
        id?: undefined;
        variable?: undefined;
    } | {
        id: string;
        status: "ok";
        variable: Record<K, {
            name: K;
            value: T;
            lastWrite: string;
        }>[K];
        error?: undefined;
    }>;
    /**
     * Get user global variables
     *
     * @version 0.2.5
     * @param platform The platform to fetch globals for (twitch, youtube, trovo)
     * @param name Optional name of the global user variable to fetch
     * @param persisted Whether the global variable is persisted
     */
    getUserGlobals<T extends StreamerbotVariableValue, K extends string = string, P extends StreamerbotPlatform = StreamerbotPlatform>(platform: P, name?: K | null, persisted?: boolean): Promise<GetUserGlobalsResponse<T, K, P>>;
    /**
     * Get user global variables
     *
     * @version 0.2.5
     * @param platform The platform to fetch globals for (twitch, youtube, trovo)
     * @param userId The user ID to fetch globals for
     * @param name Optional name of the global variable to fetch
     * @param persisted Whether the global variable is persisted
     */
    getUserGlobal<T extends StreamerbotVariableValue, K extends string = string, U extends string = string, P extends StreamerbotPlatform = StreamerbotPlatform>(platform: P, userId: U, name?: K | null, persisted?: boolean): Promise<StreamerbotErrorResponse | StreamerbotOkResponse<{
        variables: StreamerbotGlobalVariable<T, K>[];
        count: number;
    }> | {
        status: string;
        error: string;
        id?: undefined;
        variable?: undefined;
    } | {
        id: string;
        status: "ok";
        variable: StreamerbotGlobalVariable<T, K>;
        error?: undefined;
    }>;
    /**
     * Send chat messages
     *
     * Authenticated WebSocket is required
     *
     * @version 0.2.5
     * @param platform The platform to send the message to
     * @param message The message content to send
     * @param options Additional options for the message
     */
    sendMessage(platform: StreamerbotPlatform, message: string, { bot, internal, ...options }?: {
        bot?: boolean;
        internal?: boolean;
        replyId?: string;
        broadcastId?: string;
    }): Promise<SendMessageResponse>;
    /**
     * Retrieves the pronouns of a user from the specified platform.
     *
     * @param platform - The platform from which to retrieve the user's pronouns.
     * @param userLogin - The login name of the user whose pronouns are to be retrieved.
     * @returns A promise that resolves to the user's pronouns.
     */
    getUserPronouns(platform: StreamerbotPlatform, userLogin: string): Promise<GetUserPronounsResponse>;
}

export { type BroadcasterPlatform, type BroadcasterPlatforms, type ClearCreditsResponse, DefaultStreamerbotClientOptions, type DoActionResponse, type Emote, type ExecuteCodeTriggerResponse, type GetActionsResponse, type GetActiveViewersResponse, type GetBroadcasterResponse, type GetCodeTriggersResponse, type GetCommandsResponse, type GetCreditsResponse, type GetEventsResponse, type GetGlobalResponse, type GetGlobalsResponse, type GetInfoResponse, type GetMonitoredYouTubeBroadcastsResponse, type GetUserGlobalResponse, type GetUserGlobalsResponse, type GetUserPronounsResponse, type MaybeStreamerbotResponse, type MonitoredYouTubeBroadcast, type SendMessageResponse, type StreamerbotAction, StreamerbotClient, type StreamerbotClientOptions, type StreamerbotCommand, type StreamerbotCredits, type StreamerbotErrorResponse, type StreamerbotEventData, type StreamerbotEventName, type StreamerbotEventPayload, type StreamerbotEventSource, type StreamerbotEventType, type StreamerbotEventsBySource, type StreamerbotEventsSubscription, type StreamerbotEventsType, type StreamerbotEventsTypeWriteable, type StreamerbotGlobalVariable, type StreamerbotGlobalVariableName, type StreamerbotInfo, type StreamerbotOkResponse, type StreamerbotPlatform, type StreamerbotResponse, type StreamerbotResponseTypes, type StreamerbotUserGlobalVariable, type StreamerbotVariableValue, type StreamerbotViewer, type SubscribeResponse, type TestCreditsResponse, type TrovoBot, type TrovoBroadcaster, type TwitchBot, type TwitchBroadcaster, type TwitchGetEmotesResponse, type UnknownEventData, type UnsubscribeResponse, type VStreamBot, type VStreamBroadcaster, type VerifyEventSources, type VerifyEventTypes, type WebSocketStatus, type YouTubeBot, type YouTubeGetEmotesResponse, type YoutubeBroadcaster };
