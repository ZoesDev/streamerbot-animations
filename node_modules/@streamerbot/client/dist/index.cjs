"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  DefaultStreamerbotClientOptions: () => DefaultStreamerbotClientOptions,
  StreamerbotClient: () => StreamerbotClient
});
module.exports = __toCommonJS(src_exports);

// src/ws/types/events/events.const.ts
var StreamerbotEvents = {
  General: ["Custom"],
  Twitch: [
    "Follow",
    "Cheer",
    "Sub",
    "ReSub",
    "GiftSub",
    "GiftBomb",
    "Raid",
    "HypeTrainStart",
    "HypeTrainUpdate",
    "HypeTrainLevelUp",
    "HypeTrainEnd",
    "RewardRedemption",
    "RewardCreated",
    "RewardUpdated",
    "RewardDeleted",
    "CommunityGoalContribution",
    "CommunityGoalEnded",
    "StreamUpdate",
    "Whisper",
    "FirstWord",
    "SubCounterRollover",
    "BroadcastUpdate",
    "StreamUpdateGameOnConnect",
    "PresentViewers",
    "PollCreated",
    "PollUpdated",
    "PollCompleted",
    "PredictionCreated",
    "PredictionUpdated",
    "PredictionCompleted",
    "PredictionCanceled",
    "PredictionLocked",
    "ChatMessage",
    "ChatMessageDeleted",
    "UserTimedOut",
    "UserBanned",
    "Announcement",
    "AdRun",
    "BotWhisper",
    "CharityDonation",
    "CharityCompleted",
    "CoinCheer",
    "ShoutoutCreated",
    "UserUntimedOut",
    "CharityStarted",
    "CharityProgress",
    "GoalBegin",
    "GoalProgress",
    "GoalEnd",
    "ShieldModeBegin",
    "ShieldModeEnd",
    "AdMidRoll",
    "StreamOnline",
    "StreamOffline",
    "ShoutoutReceived",
    "ChatCleared",
    "RaidStart",
    "RaidSend",
    "RaidCancelled",
    "PollTerminated",
    "PyramidSuccess",
    "PyramidBroken",
    "ViewerCountUpdate",
    "GuestStarSessionBegin",
    "GuestStarSessionEnd",
    "GuestStarGuestUpdate",
    "GuestStarSlotUpdate",
    "GuestStarSettingsUpdate",
    "HypeChat",
    "RewardRedemptionUpdated",
    "HypeChatLevel",
    "BroadcasterAuthenticated",
    "BroadcasterChatConnected",
    "BroadcasterChatDisconnected",
    "BroadcasterPubSubConnected",
    "BroadcasterPubSubDisconnected",
    "BroadcasterEventSubConnected",
    "BroadcasterEventSubDisconnected",
    "SevenTVEmoteAdded",
    "SevenTVEmoteRemoved",
    "BetterTTVEmoteAdded",
    "BetterTTVEmoteRemoved",
    "BotChatConnected",
    "BotChatDisconnected",
    "UpcomingAd",
    "ModeratorAdded",
    "ModeratorRemoved",
    "VipAdded",
    "VipRemoved",
    "UserUnbanned",
    "UnbanRequestApproved",
    "UnbanRequestDenied",
    "AutomaticRewardRedemption",
    "UnbanRequestCreated",
    "ChatEmoteModeOn",
    "ChatEmoteModeOff",
    "ChatFollowerModeOn",
    "ChatFollowerModeOff",
    "ChatFollowerModeChanged",
    "ChatSlowModeOn",
    "ChatSlowModeOff",
    "ChatSlowModeChanged",
    "ChatSubscriberModeOn",
    "ChatSubscriberModeOff",
    "ChatUniqueModeOn",
    "ChatUniqueModeOff",
    "AutoModMessageHeld",
    "AutoModMessageUpdate",
    "BlockedTermsAdded",
    "BlockedTermsDeleted",
    "WarnedUser",
    "SuspiciousUserUpdate",
    "PermittedTermsAdded",
    "PermittedTermsDeleted",
    "WarningAcknowledged",
    "WatchStreak",
    "PollArchived",
    "SharedChatSessionBegin",
    "SharedChatSessionUpdate",
    "SharedChatSessionEnd",
    "PrimePaidUpgrade",
    "PayItForward",
    "GiftPaidUpgrade",
    "BitsBadgeTier",
    "SharedAnnouncement",
    "SharedRaid",
    "SharedPrimePaidUpgrade",
    "SharedGiftPaidUpgrade",
    "SharedPayItForward",
    "SharedSub",
    "SharedResub",
    "SharedSubGift",
    "SharedCommunitySubGift"
  ],
  Streamlabs: ["Donation", "Merchandise", "Connected", "Disconnected", "CharityDonation"],
  SpeechToText: ["Dictation", "Command"],
  Command: ["Triggered", "Cooldown"],
  FileWatcher: ["Changed", "Created", "Deleted", "Renamed"],
  FileTail: ["Changed"],
  Quote: ["Added", "Show"],
  Misc: [
    "TimedAction",
    "Test",
    "ProcessStarted",
    "ProcessStopped",
    "ChatWindowAction",
    "StreamerbotStarted",
    "StreamerbotExiting",
    "ToastActivation",
    "GlobalVariableUpdated",
    "UserGlobalVariableUpdated",
    "ApplicationImport"
  ],
  Raw: ["Action", "SubAction", "ActionCompleted"],
  WebsocketClient: ["Open", "Close", "Message"],
  StreamElements: ["Tip", "Merch", "Connected", "Disconnected", "Authenticated"],
  WebsocketCustomServer: ["Open", "Close", "Message"],
  DonorDrive: ["Donation", "ProfileUpdated", "Incentive"],
  YouTube: [
    "BroadcastStarted",
    "BroadcastEnded",
    "Message",
    "MessageDeleted",
    "UserBanned",
    "SuperChat",
    "SuperSticker",
    "NewSponsor",
    "MemberMileStone",
    "NewSponsorOnlyStarted",
    "NewSponsorOnlyEnded",
    "StatisticsUpdated",
    "BroadcastUpdated",
    "MembershipGift",
    "GiftMembershipReceived",
    "FirstWords",
    "PresentViewers",
    "NewSubscriber",
    "BroadcastMonitoringStarted",
    "BroadcastMonitoringEnded",
    "BroadcastAdded",
    "BroadcastRemoved",
    "SevenTVEmoteAdded",
    "SevenTVEmoteRemoved",
    "BetterTTVEmoteAdded",
    "BetterTTVEmoteRemoved"
  ],
  Pulsoid: ["HeartRatePulse"],
  HypeRate: ["HeartRatePulse", "TwitchClipCreated", "Connected", "Disconnected"],
  Kofi: ["Donation", "Subscription", "Resubscription", "ShopOrder", "Commission"],
  Patreon: ["FollowCreated", "FollowDeleted", "PledgeCreated", "PledgeUpdated", "PledgeDeleted"],
  Application: ["ActionAdded", "ActionUpdated", "ActionDeleted"],
  TipeeeStream: ["Donation"],
  TreatStream: ["Treat", "Authenticated", "Connected", "Disconnected"],
  Shopify: ["OrderCreated", "OrderPaid"],
  Obs: [
    "Connected",
    "Disconnected",
    "Event",
    "SceneChanged",
    "StreamingStarted",
    "StreamingStopped",
    "RecordingStarted",
    "RecordingStopped",
    "VendorEvent"
  ],
  Midi: ["Message"],
  HotKey: ["Press"],
  StreamDeck: ["Action", "Connected", "Disconnected", "Info"],
  Custom: ["Event", "CodeEvent"],
  VTubeStudio: [
    "ModelLoaded",
    "ModelUnloaded",
    "BackgroundChanged",
    "ModelConfigChanged",
    "HotkeyTriggered",
    "ModelAnimation",
    "Connected",
    "Disconnected",
    "TrackingStatusChanged",
    "ItemEvent",
    "ModelClicked"
  ],
  CrowdControl: [
    "GameSessionStart",
    "GameSessionEnd",
    "EffectRequest",
    "EffectSuccess",
    "EffectFailure",
    "TimedEffectStarted",
    "TimedEffectEnded",
    "TimedEffectUpdated",
    "CoinExchange"
  ],
  Elgato: [
    "WaveLinkOutputSwitched",
    "WaveLinkOutputVolumeChanged",
    "WaveLinkOutputMuteChanged",
    "WaveLinkSelectedOutputChanged",
    "WaveLinkInputVolumeChanged",
    "WaveLinkInputMuteChanged",
    "WaveLinkInputNameChanged",
    "WaveLinkMicrophoneGainChanged",
    "WaveLinkMicrophoneOutputVolumeChanged",
    "WaveLinkMicrophoneBalanceChanged",
    "WaveLinkMicrophoneMuteChanged",
    "WaveLinkMicrophoneSettingChanged",
    "WaveLinkFilterAdded",
    "WaveLinkFilterChanged",
    "WaveLinkFilterDeleted",
    "WaveLinkFilterBypassStateChanged",
    "WaveLinkConnected",
    "WaveLinkDisconnected",
    "WaveLinkInputLevelMeterChanged",
    "WaveLinkOutputLevelMeterChanged",
    "CameraHubConnected",
    "CameraHubDisconnected",
    "CameraHubWebcamConnected",
    "CameraHubWebcamrDisconnected",
    "CameraHubWebcamActivated",
    "CameraHubWebcamDeactivated",
    "CameraHubSelectedWebcamChanged",
    "CameraHubWebcamMirrored",
    "CameraHubWebcamFlipped",
    "CameraHubWebcamDeviceOrientationChanged",
    "CameraHubWebcamExposureAutoLockEnabled",
    "CameraHubWebcamExposureAutoLockDisabled",
    "CameraHubWebcamSnapshotTaken",
    "CameraHubWebcamZoomChanged",
    "CameraHubWebcamContrastChanged",
    "CameraHubWebcamWhiteBalanceChanged",
    "CameraHubWebcamAutoExposureEnabled",
    "CameraHubWebcamAutoExposureDisabled",
    "CameraHubWebcamAutoWhiteBalanceEnabled",
    "CameraHubWebcamAutoWhiteBalanceDisabled",
    "CameraHubWebcamNoiseReductionEnabled",
    "CameraHubWebcamNoiseReductionDisabled",
    "CameraHubWebcamISOChanged",
    "CameraHubWebcamShutterSpeedChanged",
    "CameraHubWebcamSharpnessChanged",
    "CameraHubWebcamAntiFlickerChanged",
    "CameraHubWebcamLensChanged",
    "CameraHubWebcamARLensChanged",
    "CameraHubWebcamBitrateChanged",
    "CameraHubWebcamFlashEnabled",
    "CameraHubWebcamFlashDisabled",
    "CameraHubWebcamPanChanged",
    "CameraHubTiltChanged",
    "CameraHubWebcamOverscanChanged",
    "CameraHubWebcamAutoFocusEnabled",
    "CameraHubWebcamAutoFocusDisabled",
    "CameraHubWebcamFocusChanged",
    "CameraHubWebcamWhiteBalanceTintChanged",
    "CameraHubWebcamBrightnessChanged",
    "CameraHubWebcamSaturationChanged",
    "CameraHubWebcamLiveISOChanged",
    "CameraHubWebcamLiveShutterSpeedChanged",
    "CameraHubWebcamLiveWhiteBalanceChanged",
    "CameraHubWebcamLiveWhiteBalanceTintChanged",
    "CameraHubPrompterConnected",
    "CameraHubPrompterDisconnected",
    "CameraHubPrompterModeChanged",
    "CameraHubPrompterBrightnessChanged",
    "CameraHubPrompterFontChanged",
    "CameraHubPrompterFontSizeChanged",
    "CameraHubPrompterAutoScrollEnabled",
    "CameraHubPrompterAutoScrollDisabled",
    "CameraHubPrompterAutoScrollChapterEnabled",
    "CameraHubPrompterAutoScrollChapterDisabled",
    "CameraHubPrompterScrollSpeedChanged",
    "CameraHubPrompterOpacityChanged",
    "CameraHubPrompterHorizontalMarginChanged",
    "CameraHubPrompterVerticalMarginChanged",
    "CameraHubPrompterLineSpacingChanged",
    "CameraHubPrompterFontColorChanged",
    "CameraHubPrompterBackgroundColorChanged",
    "CameraHubPrompterSelectedChapterChanged",
    "CameraHubPrompterChannelsChanged",
    "CameraHubPrompterSelectedChannelChanged",
    "CameraHubPrompterContrastChanged",
    "CameraHubPrompterCrosshairEnabled",
    "CameraHubPrompterCrosshairDisabled",
    "CameraHubPrompterCrosshairImageChanged",
    "CameraHubPrompterCrosshairColorChanged",
    "CameraHubPrompterSelectedScriptChanged"
  ],
  StreamlabsDesktop: [
    "Connected",
    "Disconnected",
    "SceneChanged",
    "StreamingStarted",
    "StreamingStopped",
    "RecordingStarted",
    "RecordingStopped"
  ],
  SpeakerBot: ["Connected", "Disconnected"],
  Fourthwall: [
    "ProductCreated",
    "ProductUpdated",
    "GiftPurchase",
    "OrderPlaced",
    "OrderUpdated",
    "Donation",
    "SubscriptionPurchased",
    "SubscriptionExpired",
    "SubscriptionChanged",
    "ThankYouSent",
    "NewsletterSubscribed",
    "GiftDrawStarted",
    "GiftDrawEnded"
  ],
  Trovo: [
    "BroadcasterAuthenticated",
    "BroadcasterChatConnected",
    "BroadcasterChatDisconnected",
    "FirstWords",
    "PresentViewers",
    "ChatMessage",
    "Follow",
    "SpellCast",
    "CustomSpellCast",
    "Raid",
    "Subscription",
    "Resubscription",
    "GiftSubscription",
    "MassGiftSubscription",
    "StreamOnline",
    "StreamOffline"
  ],
  ThrowingSystem: [
    "Connected",
    "WebsocketConnected",
    "WebsocketDisconnected",
    "EventsConnected",
    "EventsDisconnected",
    "ItemHit",
    "TriggerActivated",
    "TriggerEnded"
  ],
  Pallygg: ["Connected", "Disconnected", "CampaignTip"],
  StreamerBotRemote: [
    "InstanceConnected",
    "InstanceDisconnected",
    "InstanceTrigger",
    "InstanceSignal"
  ],
  VoiceMod: ["Connected", "Disconnected", "VoiceLoaded", "SoundboardChanged"],
  Group: ["Added", "Removed", "Cleared", "UsersAdded", "UsersRemoved"],
  MeldStudio: [
    "Connected",
    "Disconnected",
    "StreamingStarted",
    "StreamingStopped",
    "RecordingStarted",
    "RecordingStopped",
    "SceneChanged",
    "LayerVisbilityChanged",
    "LEffectEnabledStateChanged",
    "TrackMonitoringStateChanged",
    "TrackMustedStateChanged",
    "Event"
  ]
};

// src/ws/util/websocket.util.ts
var import_uncrypto = require("uncrypto");
function generateRequestId() {
  return `sb:client:req:${Date.now()}-${(0, import_uncrypto.getRandomValues)(new Uint32Array(12))[0]}`;
}
function getCloseEventReason(event) {
  let reason;
  if (event.code == 1e3)
    reason = "Connection closed.";
  else if (event.code == 1001)
    reason = 'Endpoint is "going away".';
  else if (event.code == 1002)
    reason = "Connection closed due to a protocol error.";
  else if (event.code == 1003 || event.code == 1007 || event.code == 1008 || event.code == 1010)
    reason = "Bad request.";
  else if (event.code == 1004)
    reason = "Reserved";
  else if (event.code == 1005)
    reason = "Missing status code.";
  else if (event.code == 1006)
    reason = "The connection was closed abnormally.";
  else if (event.code == 1009)
    reason = "Message size limit exceeded.";
  else if (event.code == 1011)
    reason = "Server terminated connection because due to unexpected condition.";
  else if (event.code == 1015)
    reason = "TLS handshake failure";
  else reason = "Unknown error";
  return reason;
}
async function withTimeout(promise, options) {
  const {
    timeout,
    message = "Operation timed out.",
    controller
  } = options;
  let timeoutId;
  return await Promise.race([
    new Promise((_, rej) => {
      timeoutId = setTimeout(() => {
        controller.abort();
        console.debug("[withTimeout] timeout reached", options);
        return rej(new Error(message));
      }, timeout);
      options.signal?.addEventListener("abort", () => {
        clearTimeout(timeoutId);
        controller?.abort();
        rej(new Error("Operation aborted."));
      }, { once: true });
    }),
    promise
  ]).finally(() => {
    clearTimeout(timeoutId);
    controller.abort();
  });
}
async function sha256base64(message) {
  const msgUint8 = new TextEncoder().encode(message);
  const hashBuffer = await import_uncrypto.subtle.digest("SHA-256", msgUint8);
  const hashArray = Array.from(new Uint8Array(hashBuffer));
  const hashHex = hashArray.map((b) => b.toString(16).padStart(2, "0")).join("");
  return hexToBase64(hashHex);
}
function hexToBase64(hexString) {
  const byteArray = new Uint8Array(hexString.match(/.{1,2}/g).map((byte) => parseInt(byte, 16)));
  const base64String = btoa(String.fromCharCode.apply(null, Array.from(byteArray)));
  return base64String;
}

// src/ws/StreamerbotClient.ts
var DefaultStreamerbotClientOptions = {
  scheme: "ws",
  host: "127.0.0.1",
  port: 8080,
  endpoint: "/",
  immediate: true,
  autoReconnect: true,
  retries: -1,
  subscribe: {}
};
var StreamerbotClient = class {
  constructor(options = DefaultStreamerbotClientOptions) {
    this._authEnabled = false;
    this._authenticated = false;
    this.listeners = [];
    this.subscriptions = {};
    this._explicitlyClosed = false;
    this._retried = 0;
    this._connectController = new AbortController();
    this._reconnectTimeout = void 0;
    this.options = { ...DefaultStreamerbotClientOptions, ...options };
    if (true === this.options.immediate) {
      this.connect().catch((e) => console.warn);
    }
  }
  /**
   * Check if the WebSocket connection is authenticated
   */
  get authenticated() {
    return !!this.socket && this.socket.readyState === this.socket.OPEN && this._authenticated;
  }
  /**
   * Connect to a Streamer.bot WebSocket server
   */
  async connect(timeout = 1e4) {
    if (this.socket?.readyState !== this.socket?.CLOSED) {
      try {
        await this.disconnect();
      } catch (e) {
      }
    }
    this._explicitlyClosed = false;
    this._connectController.abort();
    this._connectController = new AbortController();
    const controller = new AbortController();
    this._connectController.signal.addEventListener("abort", () => {
      controller.abort();
    }, { once: true });
    return await withTimeout(new Promise(async (res, rej) => {
      try {
        if (this.options.password) this._authEnabled = true;
        const uri = `${this.options.scheme}://${this.options.host}:${this.options.port}${this.options.endpoint}`;
        console.debug("Connecting to Streamer.bot WebSocket server at", uri, this._authEnabled ? "with authentication" : "");
        this.socket = !!globalThis?.process?.versions?.node ? new (await import("ws")).WebSocket(uri) : new WebSocket(uri);
        this.socket.onmessage = this.onMessage.bind(this);
        this.socket.onopen = this.onOpen.bind(this);
        this.socket.onclose = this.onClose.bind(this);
        this.socket.onerror = this.onError.bind(this);
        this.socket.addEventListener("open", () => {
          if (!this.socket) return rej(new Error("WebSocket not initialized"));
          res();
        }, { signal: controller.signal });
        this.socket.addEventListener("close", () => {
          return rej(new Error("WebSocket closed"));
        }, { once: true });
      } catch (error) {
        try {
          await this.disconnect();
          this?.options?.onError?.(error);
        } catch (e) {
          console.warn("Error invoking onError handler", e);
        }
        rej(error);
      }
    }), {
      timeout,
      message: "WebSocket connection timeout exceeded",
      controller
    });
  }
  /**
   * Disconnect Streamer.bot WebSocket
   */
  async disconnect(code = 1e3, timeout = 1e3) {
    this._explicitlyClosed = true;
    this._connectController.abort();
    this._reconnectTimeout && clearTimeout(this._reconnectTimeout);
    if (!this.socket || this.socket.readyState === this.socket.CLOSED) return;
    const controller = new AbortController();
    const signal = controller.signal;
    return await withTimeout(new Promise((res, rej) => {
      this.socket?.addEventListener("close", () => {
        console.debug("Disconnected from Streamer.bot WebSocket server");
        res();
      }, { signal });
      if (this.socket?.readyState !== this.socket?.CLOSING) {
        try {
          this.socket?.close(code);
        } catch (error) {
          rej(error);
        }
      }
    }), {
      timeout,
      message: "Timeout exceeded while closing connection",
      controller
    });
  }
  async handshake() {
    if (!this.socket) throw new Error("WebSocket not initialized");
    const controller = new AbortController();
    const { signal } = controller;
    this._connectController.signal.addEventListener("abort", () => {
      controller.abort();
    }, { once: true });
    const response = await withTimeout(
      new Promise((res, rej) => {
        this.socket?.addEventListener("message", async (event) => {
          if (!("data" in event) || !event.data || typeof event.data !== "string") {
            console.debug("Unknown message received", event);
            return;
          }
          try {
            const payload = JSON.parse(event.data);
            if (payload && "info" in payload) {
              res(payload);
            }
          } catch (e) {
            console.warn("Invalid JSON payload received", event.data);
            rej(e);
          }
        }, { signal });
      }),
      {
        timeout: 5e3,
        message: "Handshake timeout exceeded",
        controller
      }
    );
    if (!response || !("info" in response)) throw new Error("Handshake failed (invalid payload)");
    if ("request" in response && response?.request === "Hello" && response.authentication) {
      return await this.authenticate(response);
    } else if (response.info && !response.authentication) {
      console.debug("Connected to Streamer.bot WebSocket server", response.info);
      this.info = response.info;
      this.version = response.info.version;
      return;
    }
    throw new Error("Handshake failed (unknown)");
  }
  async authenticate(data) {
    if (!this._authEnabled || !this.options.password) {
      console.debug("No password provided for authentication. Checking if auth is enforced for all requests...");
      const res = await this.getInfo();
      if (res.status === "ok") {
        this._authenticated = false;
        this.version = data.info.version;
        this.info = data.info;
        return;
      }
      await this.disconnect();
      throw new Error("Authentication required");
    }
    if (!data.authentication) {
      console.debug("Missing authentication payload");
      await this.disconnect();
      throw new Error("Invalid authentication payload");
    }
    console.debug("Authenticating with Streamer.bot WebSocket server...");
    const { salt, challenge } = data?.authentication;
    const secret = await sha256base64(`${this.options.password}${salt}`);
    const authentication = await sha256base64(`${secret}${challenge}`);
    const response = await this.request({
      request: "Authenticate",
      authentication
    });
    if (response.status === "ok") {
      this._authenticated = true;
      this.version = data.info.version;
      this.info = data.info;
    } else {
      await this.disconnect();
      throw new Error("Authentication failed");
    }
  }
  async onOpen() {
    this._retried = 0;
    this._reconnectTimeout && clearTimeout(this._reconnectTimeout);
    try {
      if (!this._authEnabled) {
        void this.getInfo().catch(() => console.debug("Failed to get Streamer.bot info"));
      }
      await this.handshake();
      if (this.version && this.info) {
        console.debug(`Connected to Streamer.bot: v${this.version} (${this.info.name})`);
        this?.options?.onConnect?.(this.info);
      }
    } catch (err) {
      console.warn("Failed handshake with Streamer.bot", err);
      this.options?.onError?.(err instanceof Error ? err : new Error("Failed handshake with Streamer.bot"));
      return await this.disconnect();
    }
    try {
      if (this.options.subscribe === "*" || Object.keys(this.options.subscribe ?? {}).length) {
        await this.subscribe(this.options.subscribe);
      }
      if (Object.keys(this.subscriptions ?? {}).length) {
        await this.subscribe(this.subscriptions);
      }
      console.debug("Subscribed to requested events", this.subscriptions, this.listeners);
    } catch (e) {
      console.warn("Error subscribing to requested events", e);
    }
  }
  onClose(event) {
    this._connectController.abort();
    try {
      if ((event.type === "error" || !event.wasClean) && this.options.onError)
        this?.options?.onError(new Error(getCloseEventReason(event)));
      this?.options?.onDisconnect?.();
    } catch (e) {
      console.warn("Error invoking onDisconnect handler", e);
    }
    if (this._explicitlyClosed || !this.options.autoReconnect) {
      console.debug("Cleaning up...");
      return this.cleanup();
    }
    this._retried += 1;
    if (typeof this.options.retries === "number" && (this.options.retries < 0 || this._retried < this.options.retries)) {
      if (this._reconnectTimeout) clearTimeout(this._reconnectTimeout);
      this._reconnectTimeout = setTimeout(async () => {
        if (!!this.socket && this.socket.readyState !== this.socket.CLOSED) return;
        console.debug(`Reconnecting... (attempt ${this._retried})`);
        try {
          await this.connect(1e4);
        } catch (e) {
          if (this._retried) console.warn(`Failed to reconnect (attempt ${this._retried - 1})`, e);
        }
      }, Math.min(3e4, this._retried * 1e3));
    } else {
      console.debug("Auto-reconnect limit reached. Cleaning up...");
      this.cleanup();
    }
  }
  async onMessage(event) {
    if (!event.data || typeof event.data !== "string") {
      console.debug("Unknown message received", event);
      return;
    }
    let payload;
    try {
      payload = JSON.parse(event.data);
    } catch (e) {
      console.warn("Invalid JSON payload received", event.data);
      return;
    }
    try {
      if (this.options.onData) this?.options?.onData(payload);
    } catch (e) {
      console.warn("Error invoking onData handler", e);
    }
    if (payload?.event?.source && payload?.event?.type) {
      for (const listener of this.listeners) {
        if (!listener.events?.length) continue;
        if (!listener.events.find((event2) => {
          return event2 === "*" || event2 === `${payload?.event?.source}.${payload?.event?.type}` || event2.split(".", 2)?.[1] === "*" && event2.split(".", 2)?.[0] === payload?.event?.source;
        }))
          continue;
        try {
          listener.callback(payload);
        } catch (e) {
          console.warn("Error while invoking subscription callback", listener.events);
        }
      }
    }
  }
  onError(event) {
    console.debug("WebSocket onError", event);
    if (!!this.socket && this.socket.readyState !== this.socket.OPEN) {
      this._connectController.abort();
    }
    try {
      this?.options?.onError?.(new Error("WebSocket Error"));
    } catch (e) {
      console.warn("Error invoking onError handler", e);
    }
  }
  cleanup() {
    if (this.socket) {
      this.socket.onopen = null;
      this.socket.onclose = null;
      this.socket.onerror = null;
      this.socket.onmessage = null;
      this.socket = void 0;
    }
    this.listeners = [];
    this._retried = 0;
    this._connectController.abort();
    if (this._reconnectTimeout) clearTimeout(this._reconnectTimeout);
  }
  /**
   * Send a raw object to the Streamer.bot WebSocket
   */
  send(data) {
    this.socket?.send(JSON.stringify(data));
  }
  /**
   * Make a request to the Streamer.bot WebSocket,
   * wait for the response, and return the response data
   */
  async request(request, id = "", timeout = 1e4) {
    if (!id) id = generateRequestId();
    const controller = new AbortController();
    const signal = controller.signal;
    this._connectController.signal.addEventListener("abort", () => {
      controller.abort();
    }, { once: true });
    const response = await withTimeout(new Promise((res, rej) => {
      this.socket?.addEventListener("message", (event) => {
        if (!("data" in event) || !event.data || typeof event.data !== "string") {
          console.debug("Unknown message received", event.data);
          return;
        }
        try {
          const payload = JSON.parse(event?.data);
          if (payload?.id === id) {
            return res(payload);
          }
        } catch (e) {
          console.warn("Invalid JSON payload received", event.data);
          rej(e);
        }
      }, { signal });
      this.send({ ...request, id });
    }), {
      timeout,
      message: "Request timed out",
      controller,
      signal
    });
    if (response?.status === "ok") {
      try {
        if (this.options.onData) {
          this?.options?.onData(response);
        }
      } catch (e) {
        console.warn("Error invoking onData handler", e);
      }
      return {
        event: {
          source: "Request",
          type: request.request ?? "Unknown"
        },
        ...response
      };
    }
    throw new Error("Request failed");
  }
  /**
   * Listener for specific event data
   */
  async on(event, listener) {
    try {
      if (!event) return;
      if (event === "*") {
        const events = StreamerbotEvents;
        for (const key in events) {
          if (key === void 0) continue;
          if (!Object.keys(StreamerbotEvents).includes(key)) continue;
          const eventSource = key;
          const eventTypes = events[eventSource] ?? [];
          if (eventTypes && eventTypes.length) {
            const set = /* @__PURE__ */ new Set([...this.subscriptions[eventSource] ?? [], ...eventTypes]);
            this.subscriptions[eventSource] = [...set];
          }
        }
      } else {
        const [source, type] = event.split(".", 2);
        if (!source || !type || !(source in StreamerbotEvents)) return;
        const eventSource = source;
        const eventType = type;
        if (eventType) {
          const set = /* @__PURE__ */ new Set([
            ...this.subscriptions[eventSource] ?? [],
            ...eventType === "*" ? StreamerbotEvents[eventSource] : [eventType]
          ]);
          this.subscriptions[eventSource] = [...set];
        } else {
          throw new Error("Invalid event type");
        }
      }
      if (this.socket && this.socket.readyState === this.socket.OPEN && this.version) {
        await this.subscribe(this.subscriptions);
      }
      this.listeners.push({
        events: [event],
        callback: listener
      });
      console.debug("Added subscription for", event);
    } catch (e) {
      console.warn("Failed adding subscription for", event, e);
    }
  }
  /**
   * Subscribe to events from your connected Streamer.bot instance
   */
  async subscribe(events) {
    if (events === "*") {
      events = StreamerbotEvents;
    }
    for (const key in events) {
      if (key === void 0) continue;
      if (!Object.keys(StreamerbotEvents).includes(key)) continue;
      const eventSource = key;
      const eventTypes = events[eventSource] ?? [];
      if (eventTypes && eventTypes.length) {
        const set = /* @__PURE__ */ new Set([...this.subscriptions[eventSource] ?? [], ...eventTypes]);
        this.subscriptions[eventSource] = [...set];
      }
    }
    return await this.request({
      request: "Subscribe",
      events: this.subscriptions
    });
  }
  /**
   * Unsubscribe from events you are currently subscribed to
   */
  async unsubscribe(events) {
    if (events === "*") events = StreamerbotEvents;
    for (const key in events) {
      if (key === void 0) continue;
      if (!Object.keys(StreamerbotEvents).includes(key)) continue;
      const eventSource = key;
      const eventTypes = events[eventSource];
      if (eventTypes && eventTypes.length) {
        for (const eventType of eventTypes) {
          if (eventType) {
            if (this.subscriptions[eventSource]?.filter) {
              (this.subscriptions[eventSource] = this.subscriptions[eventSource])?.filter(
                (evt) => eventType !== evt
              );
            }
          }
        }
      }
    }
    return await this.request({
      request: "UnSubscribe",
      events
    });
  }
  /**
   * Get all possible events that may be subscribed to
   */
  async getEvents() {
    return await this.request({
      request: "GetEvents"
    });
  }
  /**
   * Get all actions from your connected Streamer.bot instance
   */
  async getActions() {
    return await this.request({
      request: "GetActions"
    });
  }
  /**
   * Get all actions from your connected Streamer.bot instance
   */
  async doAction(action, args) {
    let id, name;
    if (typeof action === "string") {
      id = action;
    } else {
      id = action.id;
      name = action.name;
    }
    return await this.request({
      request: "DoAction",
      action: {
        id,
        name
      },
      args
    });
  }
  /**
   * Get the current broadcaster account information
   */
  async getBroadcaster() {
    return await this.request({
      request: "GetBroadcaster"
    });
  }
  /**
   * Get all monitored YouTube broadcasts
   *
   * @version 0.2.5
   */
  async getMonitoredYouTubeBroadcasts() {
    return await this.request({
      request: "GetMonitoredYouTubeBroadcasts"
    });
  }
  /**
   * Get the current credits payload
   */
  async getCredits() {
    return await this.request({
      request: "GetCredits"
    });
  }
  /**
   * Test credits by populating with fake data
   */
  async testCredits() {
    return await this.request({
      request: "TestCredits"
    });
  }
  /**
   * Reset credits data
   */
  async clearCredits() {
    return await this.request({
      request: "ClearCredits"
    });
  }
  /**
   * Get information about the connected Streamer.bot instance
   */
  async getInfo() {
    return await this.request({
      request: "GetInfo"
    });
  }
  /**
   * Returns all active viewers and their user information
   */
  async getActiveViewers() {
    return await this.request({
      request: "GetActiveViewers"
    });
  }
  /**
   * Execute a custom code trigger
   */
  async executeCodeTrigger(triggerName, args) {
    return await this.request({
      request: "ExecuteCodeTrigger",
      triggerName,
      args
    });
  }
  /**
   * Get all custom code triggers
   */
  async getCodeTriggers() {
    return await this.request({
      request: "GetCodeTriggers"
    });
  }
  /**
   * Get commands for the connected Streamer.bot instance
   *
   * @version 0.2.5
   */
  async getCommands() {
    return await this.request({
      request: "GetCommands"
    });
  }
  /**
   * Get emotes for the selected platform
   *
   * @version 0.2.5
   */
  async getEmotes(platform) {
    switch (platform) {
      case "twitch":
        return await this.request({
          request: "TwitchGetEmotes"
        });
      case "youtube":
        return await this.request({
          request: "YouTubeGetEmotes"
        });
      default:
        throw new Error("Invalid platform");
    }
  }
  /**
   * Get all global variables
   *
   * @version 0.2.5
   */
  async getGlobals(persisted = true) {
    return await this.request({
      request: "GetGlobals",
      persisted
    });
  }
  /**
   * Get a global variable by name
   *
   * @version 0.2.5
   * @param name The name of the global variable to fetch
   * @param persisted Whether the global variable is persisted
   */
  async getGlobal(name, persisted = true) {
    const response = await this.request({
      request: "GetGlobal",
      variable: name,
      persisted
    });
    if (response.status === "ok") {
      if (!response.variables[name]) return { status: "error", error: "Variable not found" };
      return {
        id: response.id,
        status: response.status,
        variable: response.variables[name]
      };
    }
    return response;
  }
  /**
   * Get user global variables
   *
   * @version 0.2.5
   * @param platform The platform to fetch globals for (twitch, youtube, trovo)
   * @param name Optional name of the global user variable to fetch
   * @param persisted Whether the global variable is persisted
   */
  async getUserGlobals(platform, name = null, persisted = true) {
    const platformToRequest = {
      "twitch": "TwitchGetUserGlobals",
      "youtube": "YouTubeGetUserGlobals",
      "trovo": "TrovoGetUserGlobals"
    };
    const request = platformToRequest[platform];
    if (!request) throw new Error("Invalid platform");
    return await this.request({
      request,
      variable: name,
      persisted
    });
  }
  /**
   * Get user global variables
   *
   * @version 0.2.5
   * @param platform The platform to fetch globals for (twitch, youtube, trovo)
   * @param userId The user ID to fetch globals for
   * @param name Optional name of the global variable to fetch
   * @param persisted Whether the global variable is persisted
   */
  async getUserGlobal(platform, userId, name = null, persisted = true) {
    const platformToRequest = {
      "twitch": "TwitchGetUserGlobal",
      "youtube": "YouTubeGetUserGlobal",
      "trovo": "TrovoGetUserGlobal"
    };
    const request = platformToRequest[platform];
    if (!request) throw new Error("Invalid platform");
    const response = await this.request({
      request,
      userId,
      variable: name || null,
      persisted
    });
    if (response.status === "ok" && userId && name) {
      const variable = response.variables.find((v) => v.name === name);
      if (!variable) return { status: "error", error: "Variable not found" };
      return {
        id: response.id,
        status: response.status,
        variable
      };
    }
    return response;
  }
  /**
   * Send chat messages
   *
   * Authenticated WebSocket is required
   *
   * @version 0.2.5
   * @param platform The platform to send the message to
   * @param message The message content to send
   * @param options Additional options for the message
   */
  async sendMessage(platform, message, { bot = false, internal = true, ...options } = {}) {
    if (!this._authenticated) {
      return {
        status: "error",
        error: "Authentication required"
      };
    }
    const req = {
      platform,
      message,
      bot,
      internal
    };
    if (platform === "twitch" && options.replyId) Object.assign(req, { replyId: options.replyId });
    if (platform === "youtube" && options.broadcastId) Object.assign(req, { broadcastId: options.broadcastId });
    return await this.request({
      ...req,
      request: "SendMessage"
    });
  }
  /**
   * Retrieves the pronouns of a user from the specified platform.
   *
   * @param platform - The platform from which to retrieve the user's pronouns.
   * @param userLogin - The login name of the user whose pronouns are to be retrieved.
   * @returns A promise that resolves to the user's pronouns.
   */
  async getUserPronouns(platform, userLogin) {
    return await this.request({
      request: "GetUserPronouns",
      platform,
      userLogin
    });
  }
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  DefaultStreamerbotClientOptions,
  StreamerbotClient
});
